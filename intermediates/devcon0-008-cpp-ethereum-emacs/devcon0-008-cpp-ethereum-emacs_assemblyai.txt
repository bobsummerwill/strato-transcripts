SPEAKER_00: Foreign. Yesterday too. I am Lefteris and I will be working uh in solidity and generally C uh development for Ethereum. Um, this talk will be about having Emacs development environment um for Ethereum. It will be quite a short talk. Um, so even if you're not interested in Emacs, I guess that um it may get you interested. Quick question. Who except from Felix that I know of is actually using Emacs here? Who is using him? Who knows what is. Okay, good, great. Can we discuss Emacs versus vi? No, that's not in the. No religious world here. So uh, goals of this presentation would be to familiarize with how to develop um for CPP Ethereum M with Emacs M um and also some ways that we can develop for Ethereum in Emacs. Uh like uh, develop solidity contracts, um maybe make you guys like Imax more. That's a very ambitious goal. But yeah. So why Emacs? Right? The advantage is that along uh with Vim, it's one of the most popular editors and um. As um. As developers are our user uh base we should provide easy ways for developers to develop for Ethereum using one of the most popular editors. It's extremely customizable and uh, it's a tool that suits uh our needs since we want to be creating uh languages ides around um uh the contracts etc. Well disadvantages uh is that you really need to customize the uh editor. I mean anyone that has opened the vanilla Emacs must know that it's really a difficult thing to use. And as this um temporary computer shows um. It's a memory hog. M. Emacs for some people may mean eight megabytes and constantly swapping uh or Emacs makes a computer slow. Something that shows that uh. It actually consumes a lot of memory. Uh, just for your reference, it actually uh. The original um uh abbreviation was editor macros. So um, how do you set up a nice environment in Emacs then? If not using the vanilla editor, there are many different uh environments that you can use. I would go with uh, using a package manager called lget. Um, specify packages for C development, set them up and get to developing um. So this is Elisp code. It's ah the Lisp flavor that uh powers Emacs. Um so only with this small um uh snippet here. Basically you have a package manager that will uh install, update and synchronize your packages. Um uh, whenever you uh open your editor, whenever you open your computer, if you run Emacs As a server, which is what you should be doing. Um and also when you transfer your setup uh to a new computer it has various commands. This will be the most important uh one so you can download packages, install packages, delete or update all the packages. And for a clean NIMAX M setup basically you would have something like uh a list of packages and the call to synchronize um uh the packages. So whenever it would, if it's a new computer and it reads this setup it would contact probably GitHub, download all of these packages, build them if there's a makefile and um, load them uh into your Emacs load path. So but what uh is required for C development? Uh people will tell you different things. Um uh older developers would go with Emacs default which is seded. I would uh suggest um packages through my own experience have become um very useful over the years of development and that is RTAGs, um autocomplete flight, second projectile and one that advertising Malinka is a package that I have made which is a small um uh package that acts as glue between um the other ones. So uh Malinka, the only thing that it does is create um uh project definitions and um. So this is a project definition for Ethereum. Basically um, it feeds the data to all the other packages so um uh to tags uh creators or to syntax checkers because um we may need to, we will need to know the include directories of the project, the macros, the defines that are used, et cetera. And also we have um like uh compile commands so that we compile the project test command, tweak easily, run the tests um. Yeah rtx. So this is an amazing package that's quite new. It interfaces with Clang. It's actually not ELISP code, it's a native code. It's made in C11 and creates a client server um that um creates a. It's a client server interface that has a daemon running in the background of um um uh your operating system and creates a memory database of all the tags of your project. For CPP Ethereum, because we have one big make file that makes the whole thing it's over 2 gigabytes um which is quite a bit uh but it's uh very fast. Once the database is created you can uh find the references of um your uh uh functions where they are used. You can get up to completion and you can get um what is called uh in Clang as fixed hints. So in a bit more detail now I'm pretty sure that the resolution is not so nice but. So there is a function and you would like to see where it's used. Um, you can just basically with one key combo see all the references very easily and jump around uh the references autocompletion for example, this is from our um P, uh 2P library in C. Uh there is. Can you see it? There is a boost uh basic resolver basically from the ASIO library of Boost. And just by typing um uh R, you see the type and you get the autocompleted functions. And this happens uh without any delay like it happens in other uh um. Inferior let's say Emacs packages uh and a very nice. It's too small. A very nice uh thing that Clang has is fixes. So it kind of. It runs in real time. It runs a checker on your code that um um does static analysis and provides hints. So for example here this is from the scanner of Solidity and there is the M location is valid uh method but um it's misspelled and um the clang uh static checker actually um realizes that tells you that it's misspelled and it gives you suggestion as to how to fix it. Um, which you can um apply immediately with basically disk key combo which is a default uh but you can customize it um. Another very useful package is flightcheck that basically runs syntax checkers for any language that you may desire. Python, Lisp, C. For C, it uses the Clank synth checker. Last but not least, projectile is a must have um package for Nimux development environment because it automatically indexes and creates projects by using the version control system. So I don't really need to say that uh you know CPP Ethereum is a project. I don't need to index any files, I don't need to do anything. Um, all I need to do is remember some key combinations and um. I can easily switch between header and sources, compile the project, test it, GREP or ack or ag or whatever you have. You can also do uh version control commits um and um. Various other interesting stuff. I would refer you to the documentation of the project if you want to learn more. So that's about C, but um, what about Ethereum? Uh, so how can we develop contracts inside uh Emacs? I mean Solidity is still under development. Um, someone from the forums of uh Ethereum actually developed a Serpent mode which you can get here but uh. As for Solidity, um. Over the weekend I made the Solidity mode in Emacs which is for now uh just the syntax, um, uh, highlighter, which you can see here, and an indentation, um, so it properly indents and highlights the syntax of uh, Solidity. Uh, this is um, the contract that I think Chris um, used in his example of online uh, uh, Solid Compiler. Right, the ballot contract. So as I said, for now it is very simple, just highlighting an indentation. Um, but in the future we can provide uh, autocompletion just like any other, uh language. As soon as we get the ast uh out of uh, the Solidity compiler, we can feed it as input data to any autocomplete package in Emacs. Uh, we can also integrate with the debugger when that's possibly and also with other tools that will be developed um, for the, for the ide, for uh, Solidity. So yeah, that's it. Uh, as I said, a small presentation for imax. So, any questions or what is this Emacs thing? Are you thinking of doing something in VI as well? No. I don't even know the key bindings in vi. Cool. No questions. Okay, thanks. Sat m.

