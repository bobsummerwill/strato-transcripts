**[00:15] SPEAKER_00:** So uh, subtitle here is Vision and Roadmap. However the slides will be more somewhat technical and maybe philosophical. Uh uh but the vision is um, simple. It's to create a protocol that multiple applications can run over that is encrypted and provides certain guarantees. Um and this has become more apparent over this week that uh this is an interest and it's in demand from uh, many people. So people who are building Dapps, um we saw a few on Monday and Ethereum itself. So uh, in turning complete fashion uh, we are doing a similar thing with the network protocol in that it can be used for uh, more than just Ethereum. Um so um, a little bit about me. I uh, was born and raised in Texas. So um, the Yagni thing that Sven pointed out, we would say y' all ain't gonna need that. Um, uh which is important in networking uh because we don't uh, we don't want to put things on a network that we don't need. Um, it adds complexity and uh, that's not good. Um so before I started programming I worked uh in networking. I had a strong interest in networking and network security um, and helped uh build Internet service providers, that kind of thing. Got into programming uh, wrote, helped write a C BitTorrent tracker that um, uh was. So BitTorrent itself was controversial. Um and the reason that I mention this is because um it's important to remember that ah we're adding encryption um here and uh, this can be a double edged sword. So our objective is to build what we need for the protocol um, to have integrity and that includes encryption. Anything beyond that uh, um we would like anything beyond that to be able to be built on this protocol. If uh, it's feasible something else could come along that's better. There may be other protocols out there already uh that have the potential to facilitate this role. Um so uh, what we would like is a multi protocol peer uh to peer protocol. So right now if you use BitTorrent, um, uh the peer network that you're connected to and the things that you can do with that network and those code bases is to um, send and receive files. Um and it's really efficient um because of uh, because of how it's done. So now if we want to allow multiple protocols to use a similar peer to peer network, um, we're starting to layer things and if you have two layers um, that's usually not too difficult to do. Something just needs to be lighter than the other different properties, whatever or you you know just go back and forth. It Keeps it really simple. Um, we want to start adding more layers to this. It gets really complicated um really fast. So uh, with, with the protocol um for Ethereum, uh scalability, efficiency and usability are, are really important. Uh if, if, if, if the network is slow, um, uh I think we can all agree that that wouldn't be a good thing. Faster um network uh that's not the goal, that's not the most important thing. Um but uh, between the two this helps with robustness so the network can respond to events faster. Um DHT tables uh can be kept more up to date. So the general status of the network um can be more robust and stable if it's quick, if it's efficient. Um uh, privacy, um, we'll talk a little bit about privacy. Um um to me I think that encryption is a form of privacy. Um so if we are encrypting traffic we are automatically um, uh adding some form of privacy. So the Internet as most applications as most application developers know it um, is pretty, can be laid out simple. So uh, a lot of networks run on Ethernet or perhaps they run cell phone or adsl, uh these things, um, a lot of those. Uh, so, for example DSL actually most DSL connections use a form of Ethernet, um Internet protocol, uh TCP and udp. So an interesting thing about these protocols is they have their own sort of uh forms of how you use the protocol. So if you want to build an application that uses tcp, there's a lot of things that are going on in the background to allow that to work to begin with. So if you just took TCP and you put it on a small network, uh you're fine. If you take tcp, uh IP and you put it on the Internet, um, with just the simplest Ethernet IP and TCP IP it won't really there's a lot of problems. Um, so uh, an important part, uh, also uh, each of these, well these two have address resolution. So Ethernet has addresses and we have address resolution protocol. Um IP has addresses which um, some kind. There's ways that you can, you have discovery. So on the routing side of things we have protocols that are used for infrastructure notably MPLS is on all of them. So um, the interesting thing is that a lot of problems that large peer to peer networks need to solve to be robust um, are really problems uh that uh engineers um, uh working on uh, keeping the Internet up, uh they are problems that these engineers are also researching solutions for. So uh, to give an example of this, um, here's a diagram of just a network Diagram from a, like a test thing. And um, uh, it gets complex really quick. Um, we don't have cell phones in here. Um, uh, there's a lot of things going on with the Internet, So this isn't here, but there could be a sonnet ring here so that if one part of the fiber gets cut, everything just uh, goes the other direction around the ring. Um, so uh, yeah, um, what's the diagram? I have a hard time reading it from behind. Uh, so this is an example of different kinds of networks. So frame really switched. Um, and then for other connectivity, just imagine that every single one of these connections, uh, is a different way of the connection routes messages differently but yet they all get along on the Internet most of the time.

**[09:31] SPEAKER_01:** So can I ask very silly question?

**[09:34] SPEAKER_00:** Yes.

**[09:35] SPEAKER_01:** Like for software developer, like why do I care?

**[09:39] SPEAKER_00:** I'm um, gonna get to that. Okay, so um, uh, do we have solutions? Um, so considering privacy uh, as ah well as scalability of the Internet, um, there's a lot of people working on this. Um, IPv6, uh, is um, uh, there's a part of IPv6 that tries to help with privacy. Um now uh, one interesting thing ah about IPv6 is they are 128 bit addresses. So they're not quite large enough for us to use um, on a, on a peer to peer network that depends on cryptographic properties, uh, for um, uh, shaping the network or for um, peers connecting. And we'll get to that later. So, uh, recent issue, um, this is a blog post from an engineer at MIT. And uh, IPv6 has this really interesting thing where everybody who actually gets an address um, doesn't get a full address and they can generate their own um, private addresses just ad hoc, out of nowhere. Um, and uh, so it's kind of like an ephemeral address. But the problem is that uh, routing equipment relies on addresses that don't change, um, uh, because it can do so quickly. Um, so if every computer in the world changed its address um, every five minutes, uh, it would be really, really difficult to scale that so that uh, every message can go from its source to its destination. Um, the amount of memory and processing power for uh, core network equipment would uh, have to change or algorithms have to change. So m. Yes. So uh, um, if you're interested in IPv6 uh, and how, um, there is a project that's trying to build on IPv6 um, for privacy and encryption. It's called CJDNS, um, that's pretty cool if you want to check that out. Um, So a lot of what I'm covering here is the Internet as we know it today for most uh application developers. Um, so all major browsers today should be using TLS, uh which is like version 4 of SSL or something like that. They changed the name of it.

**[12:36] SPEAKER_01:** TCP Encrypted.

**[12:40] SPEAKER_00:** Yeah, so TLS is a protocol that runs on tcpip. So it's similar to HTTP or IMAP or POP or um, uh any application protocol um except TLS is to say well use tls. So start your connection with TLS and then it will be encrypted and then just start sending messages uh once you know that it's encrypted. So a few of the things with TLS is that TLS itself um, uh is pretty good, it's well researched. Um the attacks against uh, TLS are often edge cases and rely on attacks on other um, uh cryptographic uh algorithms or at the end of the day uh the issue is the implementation. So um, TLS used by everyone, uh today everybody uses uh, root certificate authorities, um and this is centralized, um um that works for certain use cases. But Ethereum is decentralized. So the usability of TLS is also somewhat of a black box because um, if you're a developer, um, and you write JavaScript web applications or something, there's no way for your web application to determine if it's running on an encrypted connection or not. Um and if your web application wanted to determine if it's running on an encrypted connection, it couldn't find out um, like who it's connected to over this encrypted connection. Um, the only way that we could do this right now is to actually implement TLS inside of TLS with JavaScript or something which would just be uh, not fun. Um so on a more concerning level, tls most of its problems have had to do with browsers implementing it and making it really easy to downgrade the connection. And so um, this has been used uh as an attack vector to basically when the browser goes to connect you intercept a packet and you quickly get the browser to connect with a lower uh security so say 56 bit encryption instead of um, uh AES versus AES and uh uh downgrade the line. Um uh and implementations are really geared towards running HTTP over it, uh not other protocols. So one last thing, um, uh, maybe some of us here have seen this slide before. Um and uh, again to your question, I'll cover uh, what this stuff is about and why. Um so uh, this is an image from a paper from researchers I think at Harvard. And they're basically saying okay, you can use uh, netflow analysis to figure out what's going on, uh, with torture. Um, and the reason that I present this is because um, so this isn't necessarily a problem, um, but it's something that uh, I guess you could say freedom uh, fighters and people interested in privacy and freedom. Um, uh, there's ongoing research here. So um, how do we actually have privacy? Like how can we send and receive information over the Internet? And there's no way for somebody to figure out um, what is being uh, sent and received. Um, so what's important here um, is really not the attack or its Tor or anything like that. Um, what's important to know is that uh, in data centers all over the world there's, there's equipment for netflow analysis. And what this does is this equipment reads every packet that comes into the network. Um, some of them do this based on sampling so they'll read 5% of every packet that comes onto the network and extrapolate information from that. So the purpose of this equipment is to help um, is to help their network. They don't install this equipment to eavesdrop on traffic or figure out what people are doing. Oftentimes they install this equipment because it helps figure uh, out where denial of service attacks are coming from. So back to the double edged sword thing. There's a lot of cases um, uh where um, there's a balance. Um and yeah so um, when uh, I started working on the networking stuff um, Gav was like uh yeah, so we're going to run everything on this, um, no pressure, um, this is actually really, really really applicable. Um, and I'll get to that in a bit. Um, so uh, yeah so uh, the Ethereum network protocol uh as we have it today is um, Ethereum, uh relays transactions, ah, block hashes and blocks whisper messages and filters. Right now uh, presumably Swarm will be content hashes and content blocks. Um, I'm probably missing something here. Uh, later I expect that we're going to add things like simple payment verification, um, and uh, uh so right now we also sort of have P2P here. Um, and all it does is uh exchange peers. Um so each of these protocols sort of has um, different requirements kind of. Um, so Ethereum and Swarm are both kind of hybrid. So um, that's a typo. Uh the relaying of transactions is fairly important. Relaying of blocks that can be, that can be fairly important. Uh same with relay hashes. But the Throughput of relaying blocks is much higher than the throughput uh, of relaying transactions naturally. Um, so if you wanted to send uh, 10 transactions down the line and 10 blocks, the 10 blocks are always going to use uh, more bandwidth than the 10 transactions. Um now by the way, don't know for sure. It depends on the size of the contract.

**[19:57] SPEAKER_01:** Yeah, if you understand 10 empty blocks and 10.

**[20:01] SPEAKER_00:** So if you sampled 10,000 blocks this is true. Okay. Uh, uh, because the blocks contain the transactions. So blocks are actually groups of transactions. So it could be argued that some of these messages need a higher priority than others. And what does higher priority mean on a network? Um, that means that there's lower latency, the message gets there faster than the others. So um, onto answering the question earlier um, about everything, uh, with routing and privacy, um, we won't be solving those problems with this protocol. Um, this protocol is for a stable ah, robust network protocol that's encrypted and multiple applications are running over the protocol. So um, there won't be anything to do with routing priorities. Um, multicast or broadcast. Right now multicast and broadcast is written in code so send to every peer and so uh, it's really, it's unicast, um, uh, or the direction of the flow. So uh, some protocols similar to what will be proposed, uh provide a mechanism such that you can connect to something and say um, uh, don't send me data, I'm just going to send you data. Uh, or they can say the same thing.

**[21:47] SPEAKER_01:** By the way, are you okay with me asking questions on them?

**[21:50] SPEAKER_00:** No. Wait till the end. Yeah, um, uh, um so some good reading material for all of this. Uh if you're interested or you're working on similar, um, uh, similar uh, similar systems, um, is the uh, Speedy Drafts from Google, uh, this blog post which is really recent and does a great, great job of describing um, uh network buffering and what do you do when you have to send out 100 megabytes of messages and um, you can only send out 1 megabyte, um and more in the context of scalability, not necessarily a single application, BitTorrent ah is excellent. Uh the idea of uh, uh BitTorrent, it takes a file and breaks it into a whole bunch of pieces, creates a Merkle, um Merkle root hash of it, uh and then uses that as to being able to hand out pieces, um, and the way that uh, the way that's done is applicable. Um, for the DHT stuff which I won't cover, um, uh, Amazon Dynamo blog post and kademlia Ah. Um, these are both really good. Um, the Amazon Dynamo is just a great uh, introduction. Um, so I uh, couldn't come up with a name. So it's called rlpx. And um, uh, so it will provide an encrypted line, uh, multiplexing multiple applications over the line, um, flow control, uh, and then later, uh, constraints, peer discovery and peer ratings. Um, each of these sort of fit with privacy, scalability, efficiency or usability. Um, and uh, the constraints. This could say constraints, uh, and metrics. Um, uh, which is sort of connected with the peer rating system. Um, and I don't have, I don't have slides for that. Um, um. So I swear there was a picture or something here. Yeah. Okay. Um, so encryption is the way that we're using encryption is um, uh, relatively new. So last, I don't know, five years. There's other projects that are doing this. Um, we're not the only ones. Um, but most of the web right now is encrypted with tls. And uh, uh, we know how this works with certificates and the server has a certificate and they send it back and forth and things like that. So um, what we're doing is every node, uh, every endpoint of the connection of a connection, if you want to call it that, um, uh, uh, is generated via a public private key pair and the address of the public key is the address on the, on the network, uh, or uh. Yeah, yeah. Um. So uh, of course everything should always be encrypted um, and uh, authenticated. Um so uh, I'll get to the authentication bit. Um, but so a lot of protocols, they authenticate every packet or every message. Um and uh, what's being proposed here is to um, is to have authentication essentially out of band from the application. So the wire line is doing authentication. Um, in fact this network protocol is authenticating the traffic rather than the cipher, the box cipher, um, or the application itself. Um, so uh, there was an article posted on Skype about um, uh, using crypto and I'm just going to read this. Designers and implementers should refrain from optimizing well studied protocols to achieve some specific application need unless they're prepared to revisit or reevaluate the above security group. Small insignificant changes in protocols can result in invalidating the guarantees of such proofs. Um, so a lot of factors in here, um, in this paper were uh, about key sizes and parameters. Um, and uh, this was released by Enisa, um, utilink this paper earlier. Um, so with encryption we are not changing any parameters. Um, we are Using the cryptographic primitives um as they're expected to be used. However we're combining a few things because we are multiplexing application traffic over a cryptographic channel. So um, so it's uh, we're basically changing the time in which we are processing uh information uh about uh authentication um uh it's streamed um instead of coming up with some new protocol or using uh, using a self authenticating block cipher um so. Encryption uh the first version of proposed encryption protocol is this. So uh, uh the implementation is that um I want to connect to a peer so I need to get their public IP address uh sorry, yeah public IP uh port and public key. So um, I will always have the other uh the remote public key um they might not have mine um and uh, I might get it from the dht, I might get it from another peer um ah or of course I already knew, I uh already know this disappears public key um so when the connection has started the first message that's sent by the side that initiates the connection is uh, uh they using ECIs, they use the remote's public key to encrypt um their address concatenated by uh a signature of uh information. So um, Ethereum in general is relying on our ability to recover public keys from ECDSA signatures and so um, what we're doing here is we can extract, we can recover the public key from the signature. So when the connection has started I'm um sending uh my public key key encrypted with their public key. So this also means that uh if I send this to the wrong person they're not going to be able to decrypt it um and they won't know my address. Can you please explain the sign brief key? Um this is signing with uh ECDSA and the private key is used to sign uh the ticket or the nonce. So the ticket is essentially um, uh the previous uh based on the previous session uh uh and then concatenate a random value which is used um to do uh um ephemeral diffie Hellman um so this part and how this works, uh this is similar to tls. Um we're just um, we're doing a lot of things in one message and we're relying on the fact that we know the other side's public key. Uh with web browsers today, um, you have to connect and find out what the public key is and they have to tell you the public key. Um and so we're not doing that as a part of starting the connection um and Then this nots the details of this not is in the proposal. And uh, it could move into the encrypted payload or not. Um, this needs to be reviewed, um, uh, as to whether it's better to do one way or the other. And um, uh, uh, uh, I'm open at the end of uh, afterwards of getting together with anyone who's interested in helping determine uh, what the best thing to do is because this potentially changes, um, uh, has side effects based on uh, where it's at.

**[32:14] SPEAKER_01:** So what does that not do?

**[32:16] SPEAKER_00:** Um, uh, it's used for um, changing. For updating the session. So after every successful connection, uh, you update the session. And so um, when that is combined with using ephemeral, um, uh, public keys, then if somebody steals your laptop or they steal your server and they have your private keys, um, they could have packet logged everything coming out of your server and they won't be able to decrypt it. Um, so that's a part of that. Yeah, yeah. So can you just say again what the nonsense? Tickets are derived from insight. They are used as. This one. Yeah, the ticket. So the ticket is a value that you have stored from a uh, previous session from a previous connection. And the not is because there is no value. And so this um, establishes a new value. Um, so this is similar to what's being done with tls. Um, so TLS uses this for uh, uh, uh, driving key material for the shared secret. Um, and uh, that's what we're using that for as well. Um, as I said, and I want to reiterate, um, the purpose here is to create something that we can use. This needs to be uh, reviewed. Um, uh, because while um, while we're not doing anything that's not by the book, um, there's implications on um, how we use this information to derive uh, shared secrets, um, and to update them. Um, so multiplexing, uh, is really simple because we already have it. Um, uh, right now the way that uh, we're doing it is um, each sub protocol has like 10 packets, um, uh, or five or whatever. And we're stacking those into one, um, packet type. And then based on what protocols both connections agree on, um, uh is how we determine which packet type is which packet type, uh, when we receive it. Um, I think the networking guys are familiar with this and that's called adaptive message IDs. And there's a wiki article, uh, page on this actually.

**[35:34] SPEAKER_01:** It was awesome. Why are you canceling?

**[35:37] SPEAKER_00:** Well, so the question marks. So it's been proposed that uh, uh, uh, we go to a system where we have a protocol type and a packet type and it's just two values instead of stacking them. Um, so whether we do that or not, we have to get together, we have to decide maybe tomorrow. And so. But it's an implementation thing.

**[36:12] SPEAKER_01:** So I think the idea behind the adaptive message I did was to make it harder for filters to filter us.

**[36:20] SPEAKER_00:** So.

**[36:23] SPEAKER_01:** It doesn't give serious. Yeah, it's one of them. But I kind of like it. It was smart.

**[36:30] SPEAKER_00:** Yeah, I mean I like it too.

**[36:34] SPEAKER_01:** Who's that in?

**[36:36] SPEAKER_00:** Well, there are people that don't like it. I don't think that they hate it. Um, I'm 50. 50. I like both. Um, but the adaptive message idea I think is sort of a little artistic. It's very much like rlp, um, maybe a style thing.

**[36:59] SPEAKER_01:** It's like to say, hey, we are smart.

**[37:06] SPEAKER_00:** So, flow control, um, uh, so we're not actually going to do this, but I think it's funny, um, uh that uh, messages on the Internet are obviously information on a journey through space and time. Um, uh, so what's interesting is these vehicles can uh, operate differently, um, when mixed together in the same environment. Um, and with running multiple protocols over a single line, we have a very similar thing. Um, in Berlin there's a lot of cyclists, um, which is really interesting because um, I can ride my bicycle to this office faster than I can drive a car here. Um, uh, usually five minutes faster and it takes ten minutes to cycle here. Um, so, um, also uh, applicable, um, buses, planes, mass transportation are carrying a lot of people from point A to point point B. Um and uh, um in most cases it's economical to maximize um, how the vehicles are built and how they travel. Um, flying around an empty plane across the ocean, uh, is not a good idea. Um, and so, uh, for the same reason, uh, flow control helps ensure that the bandwidth that we have available, uh, is um, uh used is maximized. Um. So one of the most similar implementations to this is spdy, um, which is for uh, HTTP over tls. This should really maybe say Google's data centers, um, instead of Googleplex. Um, and I haven't read the latest draft, but prior drafts, essentially the flow control for SPDY is for infinite space and time. Um, so my understanding of SPDY is that you can have as many applications or channels as you want and each channel does its own flow control. Um, uh, which, um, that can work really well in an environment where I have a browser and my browser connects using SPDY to an application uh, server running a certificate which matches ah, who I'm talking to. So in a peer to peer network we are connecting to peers and uh, we don't know who they are. Um, uh, uh, so uh, where this is relevant is um, that um, it might not make sense uh, for us to go this route because what Google can do with this under the assumption uh, of how browsers are working is that Google can optimize their systems from the browser all the way to the source of the multiple sources of data within their own system. So for Google, SPDY is multiplexing their entire operations, uh, which is mostly web applications, Search and uh, Gmail and Maps, um, uh, and this works great for them. It also works good for browsers because browsers are um, you hit the page, it downloads and it's done. And so the goal of SPDY is so that that happens as fast as possible. And while the protocol itself allows for all of these channels, um, a web browser, when you click and you open a page, only has a finite amount of information. And so the web browser uh, will only uh, nothing out there is going to really exploit that. Um, so uh, with rlpx we have the Ethereum protocol as it is with just a slight change on the packet type. Um, it's encrypted. Uh, and the flow control is simple, um, and uh, deterministic. Um, so for the flow control, um, what I want to do is uh, talk about that with the whiteboard as sort of a part of the Q and A. Um, uh, by the way, uh, how many people by chance have read the speedy white paper? Okay, cool. Um, uh, okay, so how does this work? Um, uh, so, um, the application uses send data, so it sends a message. Um, compression. Uh, I'm sure, uh, there's some questions on that. Um, uh, uh, header is added so these three steps. So the header may be first. Um, uh, the authentication is done uh, based on the byte stream, not on the messages. Um, and so what we say is that uh, every eight kilobytes we insert a SHA3 hash of um, the previous eight kilobytes. Um, and then so our overhead for authenticating the traffic is reduced substantially. And in addition to that, um, uh, operates on the same signal that's used, uh for framing. Um then uh, uh, encrypt the bytes, send it out, um, uh, and then we get out the other side. So uh, why is flow control um important? Um, so a uh, network connection has limited bandwidth. So in many cases network connections have a fixed bandwidth. Uh, Ethernet, uh, typically does. Um, although uh, to a single application you don't know how much bandwidth is available. Uh, it's an unknown factor that changes over time and it can change substantially. Um, and only the operating system has control over this. Um, so. Uh, with Ethereum, uh, we want to allow DAPPS to run over the same peer protocol and sometimes you have to make decisions. Um, so if you have a network connection that is only one megabit per second and you need to send 10 megabytes, um, you're going to have to wait. And if your application needs that 10 megabytes sent, uh, in a certain amount of time, um, you need to do something about this, um, uh, at least be able to tell your application the data's not going to get there in time. Um, more importantly, when you're running multiple applications over one connection, um, we don't want one application to be able to take up all of the bandwidth. Um, so when the network connection gets to the point to where it's full, uh, you can't make the network connection bigger. Um, and in fact it's quite likely that if the network connection gets full, um, congestion actually goes up and it's going to even get smaller. And your choices are to drop the packets that you're wanting to send or uh, the other option is to block the application from sending more packets. Um, in order to do this, uh, the application, our networking layer needs more information about the connection because as is, um, uh, if I want to relay 100 megabytes of blocks, um, I can tell the os to send 100 megabytes of blocks, um, and the OS might stop me at 2 megabytes or 4 megabytes or 16 megabytes. It's different for every operating system. Um, uh, so we want to employ a mechanism, um, so that there's essentially a pipe, there's bandwidth for each sub protocol that's running on the line and we want to do so in a way that uh, there's enough information exchanged between the two peers that they know when it's overflowing. Or we can also use this to know when uh, there's more bandwidth available. Um, and if there's more bandwidth available. Maybe we can use this for swarm, maybe we can use this for something else. Um, that's not a part of the protocol, uh, right now because that's an implementation detail. Um, so this is the raw spec and um, uh, this part was not in the, um, in the ether pad or on GitHub. This is currently on both. Uh, and as can be seen, uh, it needs to be cleaned up and formalized. Um, and I think it would be helpful to have some diagrams um, uh so that the implementations uh, are similar. So next steps, um, in addition to implementing this um, is uh peer discovery constraints um on the way that the flow control system works. Um, and that will imply guarantees and um, that will also imply that we will have some insight into, into what's happening on the network at ah scale when we're doing uh, testing and simulations um, and things like that. Because we can log what's happening with flow control and change some parameters and then see what happens. And so essentially uh, we can actually work over a long period of time to optimize the throughput of the entire network to optimize the throughput and the latency of the entire network. Um uh, and uh, what RLPX does is it just says that uh we have framing and that there's information that the peers will send delta uh, window updates uh, back and forth each other. Um, and then the peer rating system which is definitely an implementation detail, um, that's not a part of this um, but it's a part of LibP2P. So that an application that is actually a peer to peer application um, and depends on an exchange of peer to peer messages, um, uh, can ensure that it's connecting to good peers for what it needs. Um, so maybe your needs are Swarm right now and you aren't mining Ethereum and you don't need to download all of the, you know, you're just doing transactions and swarm, um because you're using simple payment verification um and uh, so you'll want good peers that provide uh, responsive simple payment verification. And obviously uh, however swarm works that could be another protocol um, or another implementation but um, um yeah, so peer reviews. Okay, that, that's it. Mhm. Sa.

